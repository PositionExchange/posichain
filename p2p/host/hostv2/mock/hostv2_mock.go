// Code generated by MockGen. DO NOT EDIT.
// Source: hostv2.go

// Package mock_hostv2 is a generated GoMock package.
package mock_hostv2

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	go_libp2p_pubsub "github.com/libp2p/go-libp2p-pubsub"
	reflect "reflect"
)

// MockPubSub is a mock of PubSub interface
type MockPubSub struct {
	ctrl     *gomock.Controller
	recorder *MockPubSubMockRecorder
}

// MockPubSubMockRecorder is the mock recorder for MockPubSub
type MockPubSubMockRecorder struct {
	mock *MockPubSub
}

// NewMockPubSub creates a new mock instance
func NewMockPubSub(ctrl *gomock.Controller) *MockPubSub {
	mock := &MockPubSub{ctrl: ctrl}
	mock.recorder = &MockPubSubMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockPubSub) EXPECT() *MockPubSubMockRecorder {
	return m.recorder
}

// Publish mocks base method
func (m *MockPubSub) Publish(topic string, data []byte) error {
	ret := m.ctrl.Call(m, "Publish", topic, data)
	ret0, _ := ret[0].(error)
	return ret0
}

// Publish indicates an expected call of Publish
func (mr *MockPubSubMockRecorder) Publish(topic, data interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockPubSub)(nil).Publish), topic, data)
}

// Subscribe mocks base method
func (m *MockPubSub) Subscribe(topic string, opts ...go_libp2p_pubsub.SubOpt) (*go_libp2p_pubsub.Subscription, error) {
	varargs := []interface{}{topic}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Subscribe", varargs...)
	ret0, _ := ret[0].(*go_libp2p_pubsub.Subscription)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe
func (mr *MockPubSubMockRecorder) Subscribe(topic interface{}, opts ...interface{}) *gomock.Call {
	varargs := append([]interface{}{topic}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockPubSub)(nil).Subscribe), varargs...)
}

// MockSubscription is a mock of Subscription interface
type MockSubscription struct {
	ctrl     *gomock.Controller
	recorder *MockSubscriptionMockRecorder
}

// MockSubscriptionMockRecorder is the mock recorder for MockSubscription
type MockSubscriptionMockRecorder struct {
	mock *MockSubscription
}

// NewMockSubscription creates a new mock instance
func NewMockSubscription(ctrl *gomock.Controller) *MockSubscription {
	mock := &MockSubscription{ctrl: ctrl}
	mock.recorder = &MockSubscriptionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSubscription) EXPECT() *MockSubscriptionMockRecorder {
	return m.recorder
}

// Next mocks base method
func (m *MockSubscription) Next(ctx context.Context) (*go_libp2p_pubsub.Message, error) {
	ret := m.ctrl.Call(m, "Next", ctx)
	ret0, _ := ret[0].(*go_libp2p_pubsub.Message)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Next indicates an expected call of Next
func (mr *MockSubscriptionMockRecorder) Next(ctx interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockSubscription)(nil).Next), ctx)
}

// Cancel mocks base method
func (m *MockSubscription) Cancel() {
	m.ctrl.Call(m, "Cancel")
}

// Cancel indicates an expected call of Cancel
func (mr *MockSubscriptionMockRecorder) Cancel() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cancel", reflect.TypeOf((*MockSubscription)(nil).Cancel))
}
